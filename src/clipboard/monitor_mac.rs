/// macOS clipboard monitor using NSPasteboard polling.
///
/// macOS does not have a push-based clipboard listener like Windows'
/// AddClipboardFormatListener. Instead we poll NSPasteboard.changeCount
/// on a timer. Apple's recommended approach for non-foreground apps.
#[cfg(target_os = "macos")]
#[link(name = "AppKit", kind = "framework")]
extern "C" {}

#[cfg(target_os = "macos")]
mod inner {
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    use std::sync::mpsc::Sender;
    use std::time::Duration;

    use objc2::rc::{Retained, autoreleasepool};
    use objc2::runtime::AnyObject;
    use objc2::{ClassType, class, msg_send, msg_send_id};

    use crate::clipboard::content::{ClipboardContent, ImageFormat, ImageInfo, classify_text};

    use crate::clipboard::ClipboardEvent;

    /// Poll interval for clipboard changes.
    const POLL_INTERVAL: Duration = Duration::from_millis(500);

    /// Sensitivity check result (mirrors Windows `SensitivityInfo` semantics).
    #[derive(Debug, Clone, Copy)]
    struct SensitivityInfo {
        /// Content should not be recorded at all.
        exclude: bool,
        /// Content should not be synced to cloud/server.
        no_cloud: bool,
    }

    /// Check macOS pasteboard privacy/concealed flags.
    ///
    /// On macOS 14+, NSPasteboardItem can have a `concealed` type trait.
    /// Password managers (1Password, etc.) use `org.nspasteboard.ConcealedType`
    /// or `org.nspasteboard.AutoGeneratedType` to signal sensitive content.
    /// Apps may also set `org.nspasteboard.TransientType` for temporary content
    /// that should be stored locally but not synced.
    struct SensitivityChecker;

    impl SensitivityChecker {
        /// Check the current pasteboard content for sensitivity markers.
        fn check(pasteboard: &AnyObject) -> SensitivityInfo {
            let mut info = SensitivityInfo {
                exclude: false,
                no_cloud: false,
            };

            unsafe {
                let types: Option<Retained<AnyObject>> = msg_send_id![pasteboard, types];
                if let Some(types) = types {
                    let count: usize = msg_send![&*types, count];
                    for i in 0..count {
                        let uti: Option<Retained<AnyObject>> =
                            msg_send_id![&*types, objectAtIndex: i];
                        if let Some(uti) = uti {
                            let desc: Option<Retained<AnyObject>> =
                                msg_send_id![&*uti, description];
                            if let Some(desc) = desc {
                                let cstr: *const std::ffi::c_char = msg_send![&*desc, UTF8String];
                                if !cstr.is_null() {
                                    let s = std::ffi::CStr::from_ptr(cstr).to_string_lossy();
                                    // Password managers and security apps mark
                                    // secrets with these types â€” exclude entirely.
                                    if s.contains("ConcealedType")
                                        || s.contains("AutoGeneratedType")
                                        || s.contains("OneTimeCode")
                                    {
                                        info.exclude = true;
                                        return info;
                                    }
                                    // Transient content: okay to store locally
                                    // but should not be synced to the server.
                                    if s.contains("TransientType") {
                                        info.no_cloud = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            info
        }
    }

    /// Run the macOS clipboard monitor loop. Blocks the calling thread.
    pub fn run_mac_monitor(tx: Sender<ClipboardEvent>, stop: Arc<AtomicBool>) {
        tracing::info!("macOS clipboard monitor started");

        let pasteboard: Retained<AnyObject> =
            unsafe { msg_send_id![class!(NSPasteboard), generalPasteboard] };
        let mut last_change_count: i64 = unsafe { msg_send![&*pasteboard, changeCount] };

        while !stop.load(Ordering::Relaxed) {
            std::thread::sleep(POLL_INTERVAL);

            // Each iteration needs its own autorelease pool to drain
            // temporary Objective-C objects created by msg_send calls.
            let should_break = autoreleasepool(|_| unsafe {
                let change_count: i64 = msg_send![&*pasteboard, changeCount];
                if change_count == last_change_count {
                    return false;
                }
                last_change_count = change_count;
                tracing::debug!("macOS: clipboard change detected (count: {change_count})");

                // Check sensitivity
                let sensitivity = SensitivityChecker::check(&pasteboard);
                if sensitivity.exclude {
                    tracing::debug!("macOS: skipping concealed pasteboard content");
                    return false;
                }

                // Try to read string content
                let nsstring_class: Retained<AnyObject> = msg_send_id![class!(NSString), class];
                let classes: Retained<AnyObject> =
                    msg_send_id![class!(NSArray), arrayWithObject: &*nsstring_class];
                let options: Retained<AnyObject> = msg_send_id![class!(NSDictionary), dictionary];

                let objects: Option<Retained<AnyObject>> = msg_send_id![
                    &*pasteboard,
                    readObjectsForClasses: &*classes,
                    options: &*options
                ];

                if let Some(objects) = objects {
                    let count: usize = msg_send![&*objects, count];
                    if count > 0 {
                        let first: Retained<AnyObject> =
                            msg_send_id![&*objects, objectAtIndex: 0usize];
                        let cstr: *const std::ffi::c_char = msg_send![&*first, UTF8String];
                        if !cstr.is_null() {
                            let text = std::ffi::CStr::from_ptr(cstr).to_string_lossy().to_string();
                            if !text.is_empty() {
                                tracing::debug!("macOS: captured text ({} bytes)", text.len());
                                let content = classify_text(text);
                                let event = ClipboardEvent {
                                    content,
                                    no_cloud: sensitivity.no_cloud,
                                };
                                if tx.send(event).is_err() {
                                    return true; // channel closed, break outer loop
                                }
                                return false;
                            }
                        }
                    }
                }

                // Try to read image (NSImage from pasteboard)
                let tiff_type: Retained<AnyObject> =
                    msg_send_id![class!(NSString), stringWithUTF8String: b"public.tiff\0".as_ptr()];
                let png_type: Retained<AnyObject> =
                    msg_send_id![class!(NSString), stringWithUTF8String: b"public.png\0".as_ptr()];
                let type_arr: Retained<AnyObject> =
                    msg_send_id![class!(NSArray), arrayWithObject: &*tiff_type];
                let type_arr: Retained<AnyObject> =
                    msg_send_id![&*type_arr, arrayByAddingObject: &*png_type];
                let image_types: Option<Retained<AnyObject>> = msg_send_id![
                    &*pasteboard,
                    availableTypeFromArray: &*type_arr
                ];

                if image_types.is_some() {
                    tracing::debug!("macOS: captured image from pasteboard");
                    let content = ClipboardContent::Image(ImageInfo {
                        width: 0,
                        height: 0,
                        bits_per_pixel: 0,
                        data_size: 0,
                        format: ImageFormat::Png,
                        raw_data: None,
                    });
                    let event = ClipboardEvent {
                        content,
                        no_cloud: sensitivity.no_cloud,
                    };
                    let _ = tx.send(event);
                }

                false
            });

            if should_break {
                break;
            }
        }

        tracing::info!("macOS clipboard monitor stopped");
    }
}

#[cfg(target_os = "macos")]
pub use inner::run_mac_monitor;

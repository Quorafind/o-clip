/// macOS clipboard monitor using NSPasteboard polling.
///
/// macOS does not have a push-based clipboard listener like Windows'
/// AddClipboardFormatListener. Instead we poll NSPasteboard.changeCount
/// on a timer. Apple's recommended approach for non-foreground apps.
#[cfg(target_os = "macos")]
mod inner {
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    use std::sync::mpsc::Sender;
    use std::time::Duration;

    use objc2::rc::Retained;
    use objc2::runtime::AnyObject;
    use objc2::{ClassType, class, msg_send, msg_send_id};

    use crate::clipboard::content::{ClipboardContent, ImageFormat, ImageInfo, classify_text};

    use super::super::monitor::ClipboardEvent;

    /// Poll interval for clipboard changes.
    const POLL_INTERVAL: Duration = Duration::from_millis(500);

    /// Check macOS pasteboard privacy/concealed flags.
    ///
    /// On macOS 14+, NSPasteboardItem can have a `concealed` type trait.
    /// Password managers (1Password, etc.) use `org.nspasteboard.ConcealedType`
    /// or `org.nspasteboard.AutoGeneratedType` to signal sensitive content.
    struct SensitivityChecker;

    impl SensitivityChecker {
        /// Returns true if the current pasteboard content is marked as sensitive.
        fn is_sensitive(pasteboard: &AnyObject) -> bool {
            unsafe {
                // Check for concealed type markers
                let types: Option<Retained<AnyObject>> = msg_send_id![pasteboard, types];
                if let Some(types) = types {
                    let count: usize = msg_send![&*types, count];
                    for i in 0..count {
                        let uti: Option<Retained<AnyObject>> =
                            msg_send_id![&*types, objectAtIndex: i];
                        if let Some(uti) = uti {
                            let desc: Option<Retained<AnyObject>> =
                                msg_send_id![&*uti, description];
                            if let Some(desc) = desc {
                                let cstr: *const std::ffi::c_char = msg_send![&*desc, UTF8String];
                                if !cstr.is_null() {
                                    let s = std::ffi::CStr::from_ptr(cstr).to_string_lossy();
                                    if s.contains("ConcealedType")
                                        || s.contains("AutoGeneratedType")
                                        || s.contains("OneTimeCode")
                                    {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
                false
            }
        }
    }

    /// Run the macOS clipboard monitor loop. Blocks the calling thread.
    pub fn run_mac_monitor(tx: Sender<ClipboardEvent>, stop: Arc<AtomicBool>) {
        unsafe {
            let pasteboard: Retained<AnyObject> =
                msg_send_id![class!(NSPasteboard), generalPasteboard];
            let mut last_change_count: i64 = msg_send![&*pasteboard, changeCount];

            while !stop.load(Ordering::Relaxed) {
                std::thread::sleep(POLL_INTERVAL);

                let change_count: i64 = msg_send![&*pasteboard, changeCount];
                if change_count == last_change_count {
                    continue;
                }
                last_change_count = change_count;

                // Check sensitivity
                if SensitivityChecker::is_sensitive(&pasteboard) {
                    tracing::debug!("macOS: skipping concealed pasteboard content");
                    continue;
                }

                // Try to read string content
                let nsstring_class: Retained<AnyObject> = msg_send_id![class!(NSString), class];
                let classes: Retained<AnyObject> =
                    msg_send_id![class!(NSArray), arrayWithObject: &*nsstring_class];
                let options: Retained<AnyObject> = msg_send_id![class!(NSDictionary), dictionary];

                let objects: Option<Retained<AnyObject>> = msg_send_id![
                    &*pasteboard,
                    readObjectsForClasses: &*classes
                    options: &*options
                ];

                if let Some(objects) = objects {
                    let count: usize = msg_send![&*objects, count];
                    if count > 0 {
                        let first: Retained<AnyObject> =
                            msg_send_id![&*objects, objectAtIndex: 0usize];
                        let cstr: *const std::ffi::c_char = msg_send![&*first, UTF8String];
                        if !cstr.is_null() {
                            let text = std::ffi::CStr::from_ptr(cstr).to_string_lossy().to_string();
                            if !text.is_empty() {
                                let content = classify_text(text);
                                let event = ClipboardEvent {
                                    content,
                                    no_cloud: false,
                                };
                                if tx.send(event).is_err() {
                                    break;
                                }
                                continue;
                            }
                        }
                    }
                }

                // Try to read image (NSImage from pasteboard)
                // For now, we log that an image was detected but skip pixel data
                let image_types: Option<Retained<AnyObject>> = msg_send_id![
                    &*pasteboard,
                    availableTypeFromArray: &*{
                        let tiff: Retained<AnyObject> =
                            msg_send_id![class!(NSString), stringWithUTF8String: b"public.tiff\0".as_ptr()];
                        let png: Retained<AnyObject> =
                            msg_send_id![class!(NSString), stringWithUTF8String: b"public.png\0".as_ptr()];
                        let arr: Retained<AnyObject> =
                            msg_send_id![class!(NSArray), arrayWithObjects: &*tiff, &*png, std::ptr::null::<AnyObject>()];
                        arr
                    }
                ];

                if image_types.is_some() {
                    let content = ClipboardContent::Image(ImageInfo {
                        width: 0,
                        height: 0,
                        bits_per_pixel: 0,
                        data_size: 0,
                        format: ImageFormat::Png,
                    });
                    let event = ClipboardEvent {
                        content,
                        no_cloud: false,
                    };
                    let _ = tx.send(event);
                }
            }
        }
    }
}

#[cfg(target_os = "macos")]
pub use inner::run_mac_monitor;

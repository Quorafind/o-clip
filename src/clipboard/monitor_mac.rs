// macOS clipboard monitor using NSPasteboard polling.
//
// macOS does not have a push-based clipboard listener like Windows'
// AddClipboardFormatListener. Instead we poll NSPasteboard.changeCount
// on a timer. Apple's recommended approach for non-foreground apps.
#[cfg(target_os = "macos")]
#[link(name = "AppKit", kind = "framework")]
unsafe extern "C" {}

#[cfg(target_os = "macos")]
mod inner {
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    use std::sync::mpsc::Sender;
    use std::time::Duration;

    use objc2::rc::{Retained, autoreleasepool};
    use objc2::runtime::AnyObject;
    use objc2::{class, msg_send};

    use base64::Engine;
    use base64::engine::general_purpose::STANDARD as BASE64;

    use crate::clipboard::content::{ClipboardContent, ImageFormat, ImageInfo, classify_text};

    use crate::clipboard::ClipboardEvent;

    /// Poll interval for clipboard changes.
    const POLL_INTERVAL: Duration = Duration::from_millis(500);

    /// Maximum raw image data size we'll store (10 MB).
    const MAX_IMAGE_STORE_SIZE: usize = 10 * 1024 * 1024;

    /// Sensitivity check result (mirrors Windows `SensitivityInfo` semantics).
    #[derive(Debug, Clone, Copy)]
    struct SensitivityInfo {
        /// Content should not be recorded at all.
        exclude: bool,
        /// Content should not be synced to cloud/server.
        no_cloud: bool,
    }

    /// Check macOS pasteboard privacy/concealed flags.
    ///
    /// On macOS 14+, NSPasteboardItem can have a `concealed` type trait.
    /// Password managers (1Password, etc.) use `org.nspasteboard.ConcealedType`
    /// or `org.nspasteboard.AutoGeneratedType` to signal sensitive content.
    /// Apps may also set `org.nspasteboard.TransientType` for temporary content
    /// that should be stored locally but not synced.
    struct SensitivityChecker;

    impl SensitivityChecker {
        /// Check the current pasteboard content for sensitivity markers.
        fn check(pasteboard: &AnyObject) -> SensitivityInfo {
            let mut info = SensitivityInfo {
                exclude: false,
                no_cloud: false,
            };

            unsafe {
                let types: Option<Retained<AnyObject>> = msg_send![pasteboard, types];
                if let Some(types) = types {
                    let count: usize = msg_send![&*types, count];
                    for i in 0..count {
                        let uti: Option<Retained<AnyObject>> = msg_send![&*types, objectAtIndex: i];
                        if let Some(uti) = uti {
                            let desc: Option<Retained<AnyObject>> = msg_send![&*uti, description];
                            if let Some(desc) = desc {
                                let cstr: *const std::ffi::c_char = msg_send![&*desc, UTF8String];
                                if !cstr.is_null() {
                                    let s = std::ffi::CStr::from_ptr(cstr).to_string_lossy();
                                    // Password managers and security apps mark
                                    // secrets with these types â€” exclude entirely.
                                    if s.contains("ConcealedType")
                                        || s.contains("AutoGeneratedType")
                                        || s.contains("OneTimeCode")
                                    {
                                        info.exclude = true;
                                        return info;
                                    }
                                    // Transient content: okay to store locally
                                    // but should not be synced to the server.
                                    if s.contains("TransientType") {
                                        info.no_cloud = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            info
        }
    }

    /// Run the macOS clipboard monitor loop. Blocks the calling thread.
    pub fn run_mac_monitor(tx: Sender<ClipboardEvent>, stop: Arc<AtomicBool>) {
        tracing::info!("macOS clipboard monitor started");

        let pasteboard: Retained<AnyObject> =
            unsafe { msg_send![class!(NSPasteboard), generalPasteboard] };
        let mut last_change_count: i64 = unsafe { msg_send![&*pasteboard, changeCount] };

        while !stop.load(Ordering::Relaxed) {
            std::thread::sleep(POLL_INTERVAL);

            // Each iteration needs its own autorelease pool to drain
            // temporary Objective-C objects created by msg_send calls.
            let should_break = autoreleasepool(|_| unsafe {
                let change_count: i64 = msg_send![&*pasteboard, changeCount];
                if change_count == last_change_count {
                    return false;
                }
                last_change_count = change_count;

                // Skip self-initiated clipboard writes (mirrors Windows monitor behaviour).
                if crate::clipboard::take_self_write() {
                    tracing::debug!("macOS: skipping self-initiated clipboard write");
                    return false;
                }

                tracing::debug!("macOS: clipboard change detected (count: {change_count})");

                // Check sensitivity
                let sensitivity = SensitivityChecker::check(&pasteboard);
                if sensitivity.exclude {
                    tracing::debug!("macOS: skipping concealed pasteboard content");
                    return false;
                }

                // Try to read file URLs first (higher priority than text)
                if let Some(file_paths) = read_file_urls(&pasteboard) {
                    if !file_paths.is_empty() {
                        tracing::debug!("macOS: captured {} file(s)", file_paths.len());
                        let content = ClipboardContent::Files(file_paths);
                        let event = ClipboardEvent {
                            content,
                            no_cloud: sensitivity.no_cloud,
                        };
                        if tx.send(event).is_err() {
                            return true;
                        }
                        return false;
                    }
                }

                // Try to read string content
                let nsstring_class: Retained<AnyObject> = msg_send![class!(NSString), class];
                let classes: Retained<AnyObject> =
                    msg_send![class!(NSArray), arrayWithObject: &*nsstring_class];
                let options: Retained<AnyObject> = msg_send![class!(NSDictionary), dictionary];

                let objects: Option<Retained<AnyObject>> = msg_send![
                    &*pasteboard,
                    readObjectsForClasses: &*classes,
                    options: &*options
                ];

                if let Some(objects) = objects {
                    let count: usize = msg_send![&*objects, count];
                    if count > 0 {
                        let first: Retained<AnyObject> =
                            msg_send![&*objects, objectAtIndex: 0usize];
                        let cstr: *const std::ffi::c_char = msg_send![&*first, UTF8String];
                        if !cstr.is_null() {
                            let text = std::ffi::CStr::from_ptr(cstr).to_string_lossy().to_string();
                            if !text.is_empty() {
                                tracing::debug!("macOS: captured text ({} bytes)", text.len());
                                let content = classify_text(text);
                                let event = ClipboardEvent {
                                    content,
                                    no_cloud: sensitivity.no_cloud,
                                };
                                if tx.send(event).is_err() {
                                    return true; // channel closed, break outer loop
                                }
                                return false;
                            }
                        }
                    }
                }

                // Try to read image data from pasteboard.
                // Strategy: prefer PNG data directly; fall back to TIFF and
                // convert to PNG via NSBitmapImageRep.
                if let Some(png_bytes) = read_image_as_png(&pasteboard) {
                    let data_size = png_bytes.len();
                    tracing::debug!("macOS: captured image ({} bytes PNG)", data_size);

                    // Parse PNG IHDR for dimensions
                    let (width, height, bits_per_pixel) = parse_png_ihdr(&png_bytes);

                    let raw_data = if data_size <= MAX_IMAGE_STORE_SIZE {
                        Some(BASE64.encode(&png_bytes))
                    } else {
                        None
                    };

                    let content = ClipboardContent::Image(ImageInfo {
                        width,
                        height,
                        bits_per_pixel,
                        data_size,
                        format: ImageFormat::Png,
                        raw_data,
                    });
                    let event = ClipboardEvent {
                        content,
                        no_cloud: sensitivity.no_cloud,
                    };
                    let _ = tx.send(event);
                }

                false
            });

            if should_break {
                break;
            }
        }

        tracing::info!("macOS clipboard monitor stopped");
    }

    /// Read file URLs from NSPasteboard and return as PathBuf vector.
    unsafe fn read_file_urls(pasteboard: &AnyObject) -> Option<Vec<std::path::PathBuf>> {
        // Use readObjectsForClasses to read NSURL objects
        let nsurl_class: Retained<AnyObject> = msg_send![class!(NSURL), class];
        let classes: Retained<AnyObject> =
            msg_send![class!(NSArray), arrayWithObject: &*nsurl_class];
        let options: Retained<AnyObject> = msg_send![class!(NSDictionary), dictionary];

        let urls: Option<Retained<AnyObject>> = msg_send![
            pasteboard,
            readObjectsForClasses: &*classes,
            options: &*options
        ];

        let urls = urls?;
        let count: usize = msg_send![&*urls, count];
        if count == 0 {
            return None;
        }

        let mut paths = Vec::with_capacity(count);
        for i in 0..count {
            let url: Retained<AnyObject> = msg_send![&*urls, objectAtIndex: i];

            // Check if it's a file URL
            let is_file_url: bool = msg_send![&*url, isFileURL];
            if !is_file_url {
                continue;
            }

            // Get the file path from URL
            let path_str: Option<Retained<AnyObject>> = msg_send![&*url, path];
            if let Some(path_nsstring) = path_str {
                let cstr: *const std::ffi::c_char = msg_send![&*path_nsstring, UTF8String];
                if !cstr.is_null() {
                    // SAFETY: cstr is a valid C string from NSString.UTF8String
                    let path = unsafe { std::ffi::CStr::from_ptr(cstr) }
                        .to_string_lossy()
                        .to_string();
                    paths.push(std::path::PathBuf::from(path));
                }
            }
        }

        if paths.is_empty() { None } else { Some(paths) }
    }

    /// Read image data from NSPasteboard and return it as PNG bytes.
    ///
    /// Tries `public.png` first. If unavailable, reads `public.tiff` and
    /// converts to PNG using NSBitmapImageRep.
    unsafe fn read_image_as_png(pasteboard: &AnyObject) -> Option<Vec<u8>> {
        // 1. Try PNG directly
        let png_type: Retained<AnyObject> =
            msg_send![class!(NSString), stringWithUTF8String: b"public.png\0".as_ptr()];
        let png_data: Option<Retained<AnyObject>> = msg_send![pasteboard, dataForType: &*png_type];

        if let Some(data) = png_data {
            let length: usize = msg_send![&*data, length];
            if length > 0 {
                let bytes_ptr: *const u8 = msg_send![&*data, bytes];
                // SAFETY: bytes_ptr is valid for length bytes from NSData
                let bytes = unsafe { std::slice::from_raw_parts(bytes_ptr, length) };
                return Some(bytes.to_vec());
            }
        }

        // 2. Try TIFF and convert to PNG via NSBitmapImageRep
        let tiff_type: Retained<AnyObject> =
            msg_send![class!(NSString), stringWithUTF8String: b"public.tiff\0".as_ptr()];
        let tiff_data: Option<Retained<AnyObject>> =
            msg_send![pasteboard, dataForType: &*tiff_type];

        if let Some(data) = tiff_data {
            let length: usize = msg_send![&*data, length];
            if length > 0 {
                // NSBitmapImageRep *rep = [[NSBitmapImageRep alloc] initWithData:tiffData];
                let rep: Option<Retained<AnyObject>> =
                    msg_send![class!(NSBitmapImageRep), imageRepWithData: &*data];
                if let Some(rep) = rep {
                    // NSBitmapImageFileType: PNG = 4
                    let file_type_png: usize = 4;
                    let properties: Retained<AnyObject> =
                        msg_send![class!(NSDictionary), dictionary];
                    let png_data: Option<Retained<AnyObject>> = msg_send![
                        &*rep,
                        representationUsingType: file_type_png,
                        properties: &*properties
                    ];
                    if let Some(png_data) = png_data {
                        let png_len: usize = msg_send![&*png_data, length];
                        if png_len > 0 {
                            let png_ptr: *const u8 = msg_send![&*png_data, bytes];
                            // SAFETY: png_ptr is valid for png_len bytes from NSData
                            let png_bytes = unsafe { std::slice::from_raw_parts(png_ptr, png_len) };
                            return Some(png_bytes.to_vec());
                        }
                    }
                }
            }
        }

        None
    }

    /// Parse PNG IHDR chunk to extract width, height, and bits per pixel.
    /// Returns (width, height, bits_per_pixel). Falls back to (0, 0, 0) on failure.
    fn parse_png_ihdr(data: &[u8]) -> (u32, u32, u16) {
        // PNG: 8-byte signature + 4 chunk_len + 4 "IHDR" + 4 width + 4 height + 1 bit_depth + 1 color_type
        if data.len() < 26 {
            return (0, 0, 0);
        }
        let width = u32::from_be_bytes([data[16], data[17], data[18], data[19]]);
        let height = u32::from_be_bytes([data[20], data[21], data[22], data[23]]);
        let bit_depth = data[24] as u16;
        let color_type = data[25];
        let channels: u16 = match color_type {
            0 => 1, // grayscale
            2 => 3, // RGB
            4 => 2, // grayscale + alpha
            6 => 4, // RGBA
            _ => 1,
        };
        (width, height, bit_depth * channels)
    }
}

#[cfg(target_os = "macos")]
pub use inner::run_mac_monitor;
